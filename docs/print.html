<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Forky</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        <script type="module">
        	import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        	mermaid.initialize({ startOnLoad: true });
        </script>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/custom/index.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Forky</a></li><li class="chapter-item expanded affix "><li class="part-title">Crates</li><li class="chapter-item expanded "><a href="forky_cli/index.html"><strong aria-hidden="true">1.</strong> Command Line Interface</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="forky_cli/watch.html"><strong aria-hidden="true">1.1.</strong> watch</a></li><li class="chapter-item expanded "><a href="forky_cli/mod.html"><strong aria-hidden="true">1.2.</strong> mod</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="sweet/index.html"><strong aria-hidden="true">2.</strong> Sweet</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sweet/native/index.html"><strong aria-hidden="true">2.1.</strong> Quickstart - Native</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sweet/native/runner.html"><strong aria-hidden="true">2.1.1.</strong> Native Runner</a></li><li class="chapter-item expanded "><a href="sweet/native/async.html"><strong aria-hidden="true">2.1.2.</strong> Async Tests</a></li><li class="chapter-item expanded "><a href="sweet/native/webdriver.html"><strong aria-hidden="true">2.1.3.</strong> Web Driver</a></li></ol></li><li class="chapter-item expanded "><a href="sweet/web/index.html"><strong aria-hidden="true">2.2.</strong> Quickstart - Web</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sweet/web/matchers.html"><strong aria-hidden="true">2.2.1.</strong> Matchers</a></li><li class="chapter-item expanded "><a href="sweet/web/end-to-end.html"><strong aria-hidden="true">2.2.2.</strong> End-To-End</a></li></ol></li><li class="chapter-item expanded "><a href="sweet/matchers.html"><strong aria-hidden="true">2.3.</strong> Matchers</a></li><li class="chapter-item expanded "><a href="sweet/cli.html"><strong aria-hidden="true">2.4.</strong> CLI</a></li><li class="chapter-item expanded "><a href="sweet/macros.html"><strong aria-hidden="true">2.5.</strong> Macros</a></li><li class="chapter-item expanded "><a href="sweet/workspaces.html"><strong aria-hidden="true">2.6.</strong> Workspaces</a></li><li class="chapter-item expanded "><a href="sweet/cicd.html"><strong aria-hidden="true">2.7.</strong> CI / CD</a></li><li class="chapter-item expanded "><a href="sweet/faq.html"><strong aria-hidden="true">2.8.</strong> FAQ</a></li><li class="chapter-item expanded "><a href="sweet/changelog.html"><strong aria-hidden="true">2.9.</strong> Changelog</a></li><li class="spacer"></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Misc</li><li class="chapter-item expanded "><a href="other/contributing.html"><strong aria-hidden="true">3.</strong> Contributing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Forky</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="forky"><a class="header" href="#forky">Forky</a></h1>
<p>Forky is a monorepo for rust utilities.</p>
<blockquote>
<p><em>Very early stage warning:</em></p>
<ul>
<li>breaking changes on patch versions</li>
<li>continued development not guaranteed</li>
<li>outdated docs</li>
</ul>
</blockquote>
<h2 id="crates"><a class="header" href="#crates">Crates</a></h2>
<ul>
<li><a href="./forky_cli">CLI</a></li>
<li><a href="./sweet">Sweet</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-interface"><a class="header" href="#command-line-interface">Command Line Interface</a></h1>
<h3 id="installation"><a class="header" href="#installation">Installation</a></h3>
<pre><code>cargo install forky_cli
forky --help

	Welcome to the Forky CLI!
	
	Usage: Forky CLI [COMMAND]
	
	Commands:
	  auto-fs  generate mod and css files
	  watch    execute command on file change
	  serve    serve static files
	  style    Generate types for styles
	  mod      generate mod files for your project
	  sweet    build, serve &amp; run tests in-browser
	  help     Print this message or the help of the given subcommand(s)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="watch"><a class="header" href="#watch">watch</a></h1>
<p>Analagous to <code>cargo watch</code> but allows for watch globs.</p>
<p>usage: </p>
<pre><code class="language-sh">forky watch
</code></pre>
<pre><code>Usage: forky.exe watch [OPTIONS] &lt;cmd&gt;...

Arguments:
  &lt;cmd&gt;...  the space seperated command to run, ie forky watch -- echo howdy

Options:
  -w, --watch &lt;watch&gt;    paths to watch
  -i, --ignore &lt;ignore&gt;  paths to ignore
      --once             only run once instead of watching indefinitely
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mod"><a class="header" href="#mod">Mod</a></h1>
<p>usage:</p>
<pre><code class="language-sh">forky mod
</code></pre>
<p>I like to organize projects by <em>many</em> small files and including them becomes a headache so I use a cli to auto-generate mod files that include all files in a directory.</p>
<p>Its current incarnation is zero config and opinionated so you may want to play around with it on an empty project before integrating with existing codebases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sweet"><a class="header" href="#sweet">Sweet</a></h1>
<p>Sweet is a full-stack test framework for Rust. Use a single framework for some or all of the supported test types:</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Native - Unit</td><td>Results-not-panic workflow</td></tr>
<tr><td>Native - E2E</td><td>Full support for webdriver, fantoccini etc</td></tr>
<tr><td>In-browser - Component</td><td>Test indivudual web components, framework agnostic</td></tr>
<tr><td>In-browser - E2E</td><td>Run e2e tests on actual elements via iframes</td></tr>
</tbody></table>
</div>
<p>The in-browser tests are architecturally similar to Cypress <a href="https://docs.cypress.io/guides/core-concepts/testing-types#What-is-Component-Testing">Component</a> and <a href="https://docs.cypress.io/guides/core-concepts/testing-types#What-is-E2E-Testing">e2e</a> tests. The native tests may be be compared to the likes of <a href="https://jestjs.io/">Jest</a> or <a href="https://playwright.dev/">Playwright</a>.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li>🔥 Parallel</li>
<li>🕙 Async</li>
<li>🕸️ Native &amp; In-Browser</li>
<li>🌍 E2E Tests</li>
<li>☮️ Intuitive matchers</li>
<li>🌈 Pretty output</li>
</ul>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre><code class="language-rs">#[sweet_test]
fn true_is_true() -&gt; Result&lt;()&gt; {
  expect(true).to_be_true()
}
</code></pre>
<h2 id="very-quick-start"><a class="header" href="#very-quick-start">Very Quick Start</a></h2>
<pre><code>git clone https://github.com/mrchantey/sweet-demo.git
cd sweet-demo
cargo run --example sweet
</code></pre>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>Check out the <a href="sweet/./native/index.html">quickstart page</a> or have a browse of the <a href="https://github.com/mrchantey/forky/tree/main/crates/sweet/test">tests written for sweet</a></p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Sweet has four main components:</p>
<ul>
<li><a href="sweet/./macros.html"><code>sweet!</code> defines a test suite</a></li>
<li><a href="sweet/./native/index.html"><code>#[sweet_test]</code> defines a test</a></li>
<li><a href="sweet/./matchers.html"><code>expect()</code> returns a matcher</a></li>
<li><a href="sweet/./web/end-to-end.html"><code>visit()</code> returns an iframe (e2e)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart---native"><a class="header" href="#quickstart---native">Quickstart - Native</a></h1>
<ol>
<li>edit <code>cargo.toml</code>
<pre><code class="language-toml">[dev-dependencies]
sweet = # current version here

[[example]]
name = &quot;sweet&quot;
path = &quot;test/sweet.rs&quot;
</code></pre>
</li>
<li>create file <code>test/sweet.rs</code>
<pre><code class="language-rs">#![feature(imported_main)]
pub use sweet::*;

#[sweet_test]
fn it_works() -&gt; Result&lt;()&gt;{
	assert!(true == true);
	expect(true).to_be_true()?;
	expect(&quot;foobar&quot;)
		.not()
		.to_start_with(&quot;bazz&quot;)?;
	Ok(())
}
</code></pre>
</li>
<li>run <code>cargo run --example sweet</code></li>
<li>optional - try changing the above matchers so the test fails ⚡</li>
</ol>
<p>As an example here is the output of a runner with a few tests:</p>
<p><img src="sweet/native/../images/success.png" alt="native-runner" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="native-runner"><a class="header" href="#native-runner">Native Runner</a></h1>
<p>The native runner is an alternative to vanilla rust unit and integration tests. It creates a single binary for all of your tests which speeds up compile times, see <a href="https://matklad.github.io/2021/02/27/delete-cargo-integration-tests.html">this blog</a> for more info.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>The native runner has a few cli options, run with <code>--help</code> to see them all.</p>
<pre><code class="language-sh">cargo run --example sweet --help
</code></pre>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<ul>
<li><code>[match]</code> Space seperated path globs to run, ie <code>my_test</code> or <code>/e2e/</code></li>
<li><code>-w, --watch</code> Clears screen and does not return error, for use with <code>cargo watch</code> etc</li>
<li><code>-p, --parallel</code> run tests in parallel</li>
<li><code>-s, --silent</code> don't log results</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-tests"><a class="header" href="#async-tests">Async Tests</a></h1>
<p>Sweet allows async tests but cannot tell whether all awaited futures are <code>Send</code>. </p>
<p>This is solved by adding the <code>non_send</code> attribute:</p>
<pre><code class="language-rs">
// many async functions are parallelizable
#[sweet_test]
async fn example_parrallelizable_test(){
	tokio::time::sleep(Duration::from_millis(100)).await.unwrap();
}


// some must be run on the main thread
#[sweet_test(non_send)]
async fn example_non_send_tests(){
	fantoccini::ClientBuilder::native().connect(&quot;http://example.com&quot;).await;
	bevy::app::new().add_plugins(DefaultPlugins).run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web-driver"><a class="header" href="#web-driver">Web Driver</a></h1>
<blockquote>
<p>This section is for native end-to-end tests. For in-browser end-to-end tests see <a href="sweet/native/../web/end-to-end.html">end-to-end</a>.</p>
</blockquote>
<p>Sweet can be used with fantoccini or any other webdriver client. </p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Note the <code>non_send</code> flag, as fantoccini futures are not <code>Send</code>.</p>
<pre><code class="language-rs">use fantoccini::ClientBuilder;
use fantoccini::Locator;
use sweet::*;

#[sweet_test(non_send)]
async fn connects_to_example()-&gt;Result&lt;()&gt;{
	let client = ClientBuilder::native()
		.connect(&quot;http://localhost:9515&quot;).await?;

	client.goto(&quot;https://example.com&quot;).await?;
	let url = client.current_url().await?;
	expect(url.as_ref()).to_be(&quot;https://example.com&quot;)?;

	client.close().await?;
	Ok(())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart---web"><a class="header" href="#quickstart---web">Quickstart - Web</a></h1>
<ol>
<li>Follow <a href="sweet/web/../native/index.html">native quickstart</a></li>
<li>Install the cli: <code>cargo install sweet</code>
<ul>
<li>More details on the <a href="sweet/web/../cli.html">cli page</a></li>
</ul>
</li>
<li>Run <code>sweet --example my_example</code></li>
<li>Optional - update your test to do some web stuff:
<pre><code class="language-rs">web_sys::window().unwrap()
		.document().unwrap()
		.body().unwrap()
		.set_inner_html(&quot;&lt;h1&gt;This is a heading&lt;/h1&gt;&quot;);
expect(window()).get(&quot;h1&quot;)?
	.to_contain_text(&quot;This is a heading&quot;)?;
</code></pre>
</li>
</ol>
<p>Here's an example of a runner with a few tests:</p>
<p><img src="sweet/web/../images/wasm-runner.png" alt="wasm-runner" /></p>
<blockquote>
<p>Note: the below noisy warning can be stopped by enabling <code>chrome://flags/#privacy-sandbox-ads-apis</code></p>
<p><code>Error with Permissions-Policy header: Origin trial controlled feature not enabled: 'browsing-topics'.</code></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matchers"><a class="header" href="#matchers">Matchers</a></h1>
<h2 id="expectelement"><a class="header" href="#expectelement"><code>expect(element)</code></a></h2>
<p>Querying a html element is so common Sweet has matchers for some common checks:</p>
<ul>
<li><code>to_contain_html</code></li>
<li><code>to_contain_text</code></li>
<li><code>to_contain_visible_test</code></li>
</ul>
<h2 id="intohtmlelement"><a class="header" href="#intohtmlelement"><code>Into&lt;HtmlElement&gt;</code></a></h2>
<p><code>window().unwrap().document().unwrap().body().unwrap()</code> is a bit of a mouthful 🥴</p>
<p>Sweet provides some wrappers around common types, ie <code>Option&lt;Window&gt;</code>:</p>
<pre><code class="language-rs">//window implements Into&lt;HtmlElement&gt; by getting its document body
expect(web_sys::window()).to_contain_text(&quot;sweet as!&quot;)?;

//so does iframe
let page = visit(&quot;localhost:7777&quot;).await;
expect(page).to_contain_text(&quot;sweet as!&quot;)?;
</code></pre>
<h2 id="async-matchers"><a class="header" href="#async-matchers">Async Matchers</a></h2>
<p>Lots of web stuff happens at weird times, so we've got helpers like <code>poll()</code>, which will wait for 2 seconds before failing.</p>
<pre><code class="language-rs">expect(page).poll(|p|
	p.to_contain_text(&quot;sweet as!&quot;)).await?;
</code></pre>
<p>We can also retrieve child elements via polling</p>
<pre><code class="language-rs">expect(page).poll(|p| p.get(&quot;div&quot;)).await?
	.to_contain_text(&quot;sweet as!&quot;)?;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="end-to-end"><a class="header" href="#end-to-end">End-To-End</a></h1>
<blockquote>
<p>This section is for in-browser end-to-end tests. For native end-to-end tests see <a href="sweet/web/../native/webdriver.html">webdriver</a>.</p>
</blockquote>
<p>By default web tests run inside the iframe. This is great for testing components, but when we want to test a page provided by the server we need a different approach.</p>
<p>Test cases marked as <code>e2e</code> will run in the parent process instead. The child <code>iframe</code> can be retrieved via <code>visit()</code>, at which point you can interact with the underlying document just like with unit tests.</p>
<p>Testing iframes from different origins can be <a href="https://docs.cypress.io/guides/guides/web-security">tricky</a>, by default a web browser will say &quot;hey, this isnt your site, i won't let you see whats inside <code>iframe.contentDocument</code> etc&quot;. </p>
<p>To make this easier, sweet provides a reverse proxy that will serve your url from the same origin. Its been tested on simple sites like these docs, but if you encounter any problems please create an issue.</p>
<h3 id="visit"><a class="header" href="#visit"><code>visit()</code></a></h3>
<p>visit does three things:</p>
<ol>
<li>Points the proxy to the provided url</li>
<li>Sets the iframe <code>src</code> to the proxy url
<ul>
<li>fyi this is will be something like <code>/_proxy_/http://localhost:3000</code></li>
</ul>
</li>
<li>awaits the iframe <code>load</code> event</li>
</ol>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>Here's an example of an end-to-end test running on these docs:</p>
<pre><code class="language-rs">sweet!{
	test e2e &quot;docs origin&quot; {
		let page = visit(&quot;http://localhost:3000&quot;).await?;
		expect(page)
			.poll(|p|p.to_contain_text(&quot;Forky&quot;)).await?;
	}
}
</code></pre>
<p>And the output looks like this:</p>
<p><img src="sweet/web/../images/end-to-end.png" alt="end-to-end" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matchers-1"><a class="header" href="#matchers-1">Matchers</a></h1>
<p>Matchers are an ergonomic way to make assertions. Providing intellisense and type-specific assertions, they can make for an enjoyable testing experience.</p>
<p>The <code>expect(val)</code> function returns a <code>Matcher&lt;T&gt;</code> where <code>T</code> is the type of the value passed in. What assertions are available for that matcher depend on the </p>
<pre><code class="language-rs">expect(true).to_be_false()?;
</code></pre>
<img src="sweet/images/failure.png" width=50%>
<h2 id="negation"><a class="header" href="#negation">Negation</a></h2>
<p>All matchers can be negated by calling <code>not()</code></p>
<pre><code class="language-rs">expect(&quot;foobar&quot;).not().to_contain(&quot;bazz&quot;)?;
</code></pre>
<h2 id="built-in-matchers"><a class="header" href="#built-in-matchers">Built-in Matchers</a></h2>
<p>Some examples of built-in matchers are:</p>
<ul>
<li>String
<pre><code class="language-rs">expect(&quot;foobar&quot;).to_start_with(&quot;foo&quot;)?;
</code></pre>
</li>
<li>Result
<pre><code class="language-rs">  expect(my_result).to_be_ok()?;
</code></pre>
</li>
<li>Numbers (ord)
<pre><code class="language-rs">expect(2).to_be_greater_than(1)?;
</code></pre>
</li>
</ul>
<h2 id="extending-matchers"><a class="header" href="#extending-matchers">Extending Matchers</a></h2>
<p>Matchers are easy to extend, particulary using the <code>extend</code> crate.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use anyhow::Result;
</span><span class="boring">use extend::ext;
</span><span class="boring">use sweet::*;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span>struct Awesomeness(u32);

#[ext]
pub impl Matcher&lt;Awesomeness&gt; {
	fn to_be_more_awesome_than(&amp;self, other:Awesomeness) -&gt; Result&lt;()&gt; {
		let outcome = self.0 &gt; other.0;
		let expected = format!(&quot;to be more awesome than {:?}&quot;, other);
		self.assert_correct(outcome, &amp;expected)
	}
}
<span class="boring">}</span></code></pre></pre>
<p>Note that here we are calling <code>self.assert_correct()</code> which does to things:</p>
<ul>
<li>checks the outcome is true, or false in the case of negation:
<ul>
<li><code>expect(foo).not().to_be_more_awesome_than(bar)</code></li>
</ul>
</li>
<li>Formats a pretty backtraced output error if needed.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sweet-cli"><a class="header" href="#sweet-cli">Sweet CLI</a></h1>
<p>The Sweet CLI is a tool for building, serving &amp; running tests in-browser. It can:</p>
<ul>
<li>Build the tests with <code>cargo build</code> &amp; <code>wasm bindgen</code></li>
<li>Serve the tests on a dev server with live reload</li>
<li>Run the tests using <code>chromedriver</code></li>
</ul>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage:</a></h2>
<pre><code class="language-sh"># headless
sweet --example my_test
# interactive
sweet --example my_test --interactive
# workspaces
sweet --example my_test -p my_crate
# help
sweet --help
</code></pre>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/reference/cli.html">wasm-bindgen-cli</a>
<ul>
<li><code>cargo install -f wasm-bindgen-cli</code></li>
</ul>
</li>
<li><a href="https://chromedriver.chromium.org/downloads">chromedriver</a>
<ul>
<li>Not required for interactive mode</li>
<li>
<pre><code class="language-sh">  # windows
  choco install chromedriver
  # mac
  brew install --cask chromedriver
  # linux
  sudo apt install chromium-chromedriver
</code></pre>
</li>
<li>If your chrome version gets updated you will need to update chromedriver too:</li>
<li><code>choco upgrade chromedriver</code> etc</li>
</ul>
</li>
</ul>
<h2 id="help"><a class="header" href="#help">Help</a></h2>
<pre><code>sweet --help

Arguments:
  [match]...  filter suites by path glob, ie `my_test` or `/e2e/`

Options:
  -p, --package &lt;package&gt;  pass the --package flag to cargo run
      --release            pass the --release flag to cargo run
      --secure             run the dev server with https
      --static &lt;static&gt;    directory for static files (ie .css) used by component tests
  -w, --watch              live reload file changes
      --headed             run the tests with a visible browser window        
  -i, --interactive        just start the server for viewing in your browser 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<h1 id="sweet_test"><a class="header" href="#sweet_test"><code>#[sweet_test]</code></a></h1>
<p>Tests can be declared via an attribute.</p>
<pre><code class="language-rs">#[sweet_test]
fn foobar(){}

//accepts several flags, async functions or an `anyhow::Result` return type
#[sweet_test(skip,only,e2e,non_send)]
async fn foobar()-&gt;Result&lt;()&gt;{
	expect(true).to_be_true()
}
</code></pre>
<h1 id="sweet-1"><a class="header" href="#sweet-1"><code>sweet!</code></a></h1>
<p>A layout more familiar to front-end developers. Note that rust formatters may not indent etc. the contents of this macro correctly.</p>
<pre><code class="language-rs">sweet!{
	it &quot;has less boilerplate&quot; {
		expect(true).to_be_true()?;
	}
	test &quot;is an alias for it&quot;{}
	it skip &quot;wont run&quot;{}
	it only &quot;will exclude non-onlys in this suite&quot;{}
	it e2e &quot;(in-browser) runs in the parent process&quot;{}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workspaces"><a class="header" href="#workspaces">Workspaces</a></h1>
<p>Workspaces are fully supported by Sweet, here's a few notes:</p>
<h2 id="duplicate-binaries"><a class="header" href="#duplicate-binaries">Duplicate Binaries</a></h2>
<p>As per <a href="https://github.com/rust-lang/cargo/pull/6308">this PR</a> crates that contain identical example names is not supported. For this reason it is recommended to update your <code>Cargo.toml</code>.</p>
<pre><code class="language-diff">[[example]]
- name = &quot;sweet&quot;
+ name = &quot;test_crate_a&quot;
path = &quot;test/sweet.rs&quot;
</code></pre>
<p>This will achieve two things:</p>
<ul>
<li>Avoid weird bugs where running <code>crate_a</code> actually runs <code>crate_b</code></li>
<li>Reduce unneseccary recompilation.</li>
</ul>
<p>Running <code>cargo run -p crate_a --example sweet_crate_a</code> is a bit of a mouthfull, I solve this with <a href="https://github.com/casey/just">just</a>:</p>
<pre><code class="language-sh">#justfile
test crate *args:
	cargo run -p {{crate}} --example sweet_{{crate}} -- {{args}}
</code></pre>
<p>Now you can run:
<code>just test crate_a</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ci--cd"><a class="header" href="#ci--cd">CI / CD</a></h1>
<p>Sweet has full CI/CD support for all test types. In fact, the <a href="https://github.com/mrchantey/forky/blob/main/.github/workflows/test.yml">tests for this repo</a> are all run using Github Actions.</p>
<p>An example workflow may look something like <a href="https://github.com/mrchantey/sweet-demo/blob/main/.github/workflows/test.yml">this</a>:</p>
<pre><code class="language-yaml">name: 🔎 Test Crates
on:
  push:
    branches: main
  pull_request:
    branches: main
env:
  CARGO_TERM_COLOR: always
jobs:
  build_and_test:
    name: Build and Test
    runs-on: ubuntu-latest
    steps:
    - name: 📂 Checkout
      uses: actions/checkout@v3
    - name: 📂 Cache
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/bin/
          ~/.cargo/registry/index/
          ~/.cargo/registry/cache/
          ~/.cargo/git/db/
          target/
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
    - name: 🔨 Install Chromedriver
      uses: nanasess/setup-chromedriver@v2
    - name: 🔨 Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: nightly
        override: true
        default: true
    - name: 🔨 Install Wasm Target
      run: rustup target add wasm32-unknown-unknown
    - name: 🔨 Install Wasm Bindgen
      uses: baptiste0928/cargo-install@v2
      with:
        crate: wasm-bindgen-cli
        version: '0.2.87' # TODO ensure this matches your wasm-bindgen version
    - name: 🔨 Install Sweet Cli
      uses: baptiste0928/cargo-install@v2
      with:
        crate: sweet-cli
    - name: 🔨 Build
      run: cargo build
    - name: 🔎 Test Native
      run: cargo run --example sweet
    - name: 🔎 Test Wasm
      run: sweet --example sweet
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h3 id="why-use-example-instead-of-test"><a class="header" href="#why-use-example-instead-of-test">Why use <code>[[example]]</code> instead of <code>[[test]]</code></a></h3>
<p>This makes it easier for the wasm test runner to produce cleaner output, but if you're only running native tests feel free to use <code>[[test]]</code> with <code>harness=false</code>.</p>
<h3 id="what-about-wasm-bindgen-test"><a class="header" href="#what-about-wasm-bindgen-test">What about wasm-bindgen-test?</a></h3>
<p>Sweet has different priorities from <a href="https://rustwasm.github.io/wasm-bindgen/wasm-bindgen-test/index.html">wasm-bindgen-test</a> in its current state, namely a focus on UI &amp; interactivity.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<h2 id="todo"><a class="header" href="#todo">TODO</a></h2>
<ul>
<li>Kill long-running tests</li>
<li>Display typename in failed tests: <code>tests::foo::works</code></li>
</ul>
<h2 id="main"><a class="header" href="#main">main</a></h2>
<ul>
<li>rename <code>bevy_ecs</code> feature to <code>bevy</code></li>
<li>move time extensions to <code>bevy</code> feature</li>
</ul>
<h2 id="0133---17102023"><a class="header" href="#0133---17102023"><code>0.1.33</code> - 17/10/2023</a></h2>
<ul>
<li>modularity &amp; improved documentation</li>
</ul>
<h2 id="0132---13102023"><a class="header" href="#0132---13102023"><code>0.1.32</code> - 13/10/2023</a></h2>
<ul>
<li>attribute macros</li>
</ul>
<h2 id="0131---13092023"><a class="header" href="#0131---13092023"><code>0.1.31</code> - 13/09/2023</a></h2>
<ul>
<li>Headless in-browser tests</li>
<li>ci/cd workflows</li>
</ul>
<h2 id="0119---10082023"><a class="header" href="#0119---10082023"><code>0.1.19</code> - 10/08/2023</a></h2>
<ul>
<li>End-to-end testing</li>
<li>Nicer async ergonomics: <code>matcher.poll().await?</code></li>
</ul>
<h2 id="0118---03082023"><a class="header" href="#0118---03082023"><code>0.1.18</code> - 03/08/2023</a></h2>
<ul>
<li>Component Testing</li>
<li>Native Testing</li>
<li>Parallel</li>
<li>Async</li>
<li>Wasm Runner</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>If this project is of interest to you feel free to have a dig around! </p>
<p>Everything is very early days so there are no doubt lots of bugs and missing features. If you find something that could be improved please open an issue or PR.</p>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<p>Most of this is for my own reference, but you may find it useful:</p>
<ol>
<li>Install Rust
<ul>
<li><a href="https://www.rust-lang.org/tools/install">Installer</a></li>
<li>Use powershell and be sure to carefully follow steps for build tools</li>
</ul>
</li>
<li>Install Depedencies
<ul>
<li>
<pre><code class="language-sh">  	choco install just
  	choco install cygwin
  	# check
  	just all check
  	# tools
  	cargo install cargo-watch cargo-edit
  	rustup toolchain install nightly
  	rustup component add rustfmt --toolchain nightly
  	cargo +nightly fmt
  	rustup default nightly
  	# test - compilation will take several minutes
  	just all test
</code></pre>
</li>
</ul>
</li>
</ol>
<h2 id="cygwin"><a class="header" href="#cygwin">Cygwin</a></h2>
<p>Justfiles require cygwin to work on windows.</p>
<ol>
<li>install cygwin</li>
<li>add to path: <code>C:\tools\cygwin\bin</code></li>
</ol>
<h2 id="wasm"><a class="header" href="#wasm">Wasm</a></h2>
<ul>
<li>follow the <a href="https://bevy-cheatbook.github.io/platforms/wasm.html">bevy guide</a></li>
<li>setup
<pre><code class="language-sh">rustup target install wasm32-unknown-unknown
cargo install wasm-server-runner
cargo install -f wasm-bindgen-cli
#.cargo/config.toml
[target.wasm32-unknown-unknown]
runner = &quot;wasm-server-runner&quot;
</code></pre>
</li>
<li>run
<pre><code class="language-sh">#run
cargo run -p forky_play --example maze --target wasm32-unknown-unknown
#compile
cargo build -p forky_play --example maze --release --target wasm32-unknown-unknown
#build bindings
wasm-bindgen --out-dir ./html/maze --target web ./target/wasm32-unknown-unknown/release/examples/maze.wasm
cd html &amp;&amp; live-server
</code></pre>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/custom/index.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
